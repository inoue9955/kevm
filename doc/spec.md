# KeVM 仕様書

## アーキテクチャ

### 特徴
KeVM は次のような特徴がある．
* 演算命令のオペランドにはレジスタを指定する(レジスタマシン)．
* プログラムの命令列を格納する領域とデータを格納する領域が分かれている．
* データ用メモリへのアクセスはロードストア命令を介してのみ可能である．アドレッシングモードはレジスタ間接のみである．
* レジスタ数に制限はない．

### 構成
KeVM は次の主要なコンポーネントで構成される．
* プログラム
  * 実行するプログラム．
  * 単一の命令列で構成される．つまり，関数毎に分割されてはいない．
* 汎用レジスタ群: r1, r2, ...
  * レジスタにはどんなデータ型のデータでも1つだけ格納できる．
  * レジスタの数に制限はない．
  * 全てのレジスタの機能は同等でる．特定のレジスタだけしか指定できないような命令は存在しない．
* データ用メモリ(以下，単にメモリと言う)
  * 番地を伴ってロードストア命令でアクセスできる．
  * 各番地にはどんなデータ型のデータでも1つだけ格納できる．
  * 番地は 0 以上の整数で指定する．番地の上限は2^31-1である．

## データ型

KeVM が扱うデータ型には次の型がある．
* 整数型: -2^31以上2^31-1以下の整数を表す．数値のほか，メモリの番地としても利用する．
* 文字列型: 文字列を表す．
* 実行番地型: プログラムの命令列中の位置を表す．関数呼び出しの戻り番地として使われる．整数型とは区別される．

レジスタやメモリの各番地には，これらのデータ型のうちのいずれかの型を持つデータが格納される．

## プログラム

プログラムは命令の列である．列の先頭から実行を開始する． EXIT 命令を実行すると，プログラムの実行を終了する．

プログラム中の命令にはラベルを付加することができる．ラベルは英字から始まり英数字で構成された列である．ラベルの末尾にコロンを追加したものを，ラベルを付加したい命令の直前に書く．

## 命令セット

### 定数ロード命令

#### NUMBER
```
NUMBER rd, N
```
##### 説明
レジスタ rd に整数型の整数 N を格納する．ただし， N は -2^31 以上 2^31 - 1 以下の整数でなければならない．
```
rd := N
```

#### STRING
```
STRING rd, S
```
#### 説明
レジスタ rd に文字列型の文字列 S を格納する．
```
rd := S
```

### データ転送命令

#### MOVE
```
MOVE rd, rs
```
##### 説明
レジスタ rd にレジスタ rs の内容を格納する．
```
rd := rs
```

### ロードストア命令

#### LOAD
```
LOAD ra, rd
```
##### 説明
メモリの，レジスタ ra が示す番地の内容を，レジスタ rd に格納する．
ra の内容は整数型でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
rd := memory[ra]
```

#### STORE
```
STORE ra, rs
```
##### 説明
メモリの，レジスタ ra が示す番地に，レジスタ rs の内容を格納する．
ra の内容は整数型でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
memory[ra] := rs
```


### 演算命令

#### ADD
```
ADD rd, ra, rb
```
##### 説明
レジスタ rd にレジスタ ra と rb の和を格納する．レジスタ ra と rb の内容は整数でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
if typeof(rb) != INTEGER then
  error
end
rd := ra + rb
```

#### SUB
#### MUL
#### DIV
#### AND
```
AND rd, ra, rb
```
##### 説明
レジスタ rd にレジスタ ra と rb のビット毎の論理積を格納する．レジスタ ra と rb の内容は整数型でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
if typeof(rb) != INTEGER then
  error
end
rd = ra & rb
```

#### OR
#### XOR

### 比較命令

#### EQ
```
EQ rd, ra, rb
```
##### 説明
ra と rb の内容が等しければレジスタ rd に 1 を，そうでなければレジスタ rd に 0 を格納する．
```
if ra = rb then
  rd := 1
else
  rd := 0
end
```

#### NE
#### LT
#### GT

### 分岐命令

#### JMP
```
JMP LABEL
```
##### 説明
ラベル LABEL が付いている命令に制御を移す．
```
goto LABEL
```

#### JMPT
```
JMPT r, LABEL
```
##### 説明
レジスタ r の内容が 0 でないとき，ラベル LABEL が付いている命令に制御を移す．
```
if r != 0 then
  goto LABEL
end
```

#### JMPF
```
JMPF r, LABEL
```
##### 説明
レジスタ r の内容が 0 のとき，ラベル LABEL が付いている命令に制御を移す．
```
if r != 0 then
  goto LABEL
end
```

#### CALL
```
CALL r, LABEL
```
##### 説明
戻り番地をレジスタ r に格納して， LABEL が付いている命令に制御を移す．戻り番地は実行番地型のデータである．
```
r := next_address(PC)
goto LABEL
```

#### RET
```
RET r
```
##### 説明
レジスタ r に格納されている番地に制御を移す．レジスタ r の内容は実行番地型でなければならない．
```
if typeof(r) != EXEC_ADDRESS then
  error
end
goto r
```

#### EXIT
```
EXIT
```
##### 説明
プログラムの実行を終了する．


## 組込み関数

### KeVM 標準関数呼出し規約

組込み関数の呼出しは，以下の KeVM 標準関数呼出し規約に従う．

#### 名前
関数名をラベルとする．

#### スタック
メモリ中にスタックを作る．スタックは上位番地に向かって伸びる．スタックトップの番地は r8 レジスタに格納する（r8 をスタックポインタとして利用する）． r8 レジスタは，有効なデータが格納された最上位の番地を保持する．

#### 関数呼び出し
* 戻り番地は r7 レジスタに格納する．つまり，`CALL r7 LABEL`で呼出す．
* 引数: 第 4 引数までの引数は r1, r2, r3, r4 レジスタに第 1 引数から順に格納して呼出す．それ以降の引数はスタックに積む．スタックトップが最後の引数になるよう，前の引数から順にスタックに積む．
* 戻り値: 戻り値は r1 レジスタに格納して戻る．
* レジスタの保存: 関数呼び出しから戻ると， r1 から r7 レジスタの内容は変化している可能性がある．それ以外のレジスタの内容は保存される．

### 組込み関数

#### get
```
INTEGER get()
```
入力から 10 進数をひとつ読み込んで，整数型のデータとして返す．

#### put
```
put(INTEGER x)
put(STRING x)
```
1 つ引数を受けとり，それを表示する．引数は整数型か文字列型でなければならない．
