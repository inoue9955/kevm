# KeVM 仕様書

## アーキテクチャ

### 特徴
KeVM は次のような特徴がある．
* 演算命令のオペランドにはレジスタを指定する(レジスタマシン)．
* プログラムの命令列を格納する領域とデータを格納する領域が分かれている．
* データ用メモリへのアクセスはロードストア命令を介してのみ可能である．アドレッシングモードはレジスタ間接のみである．
* レジスタ数に制限はない．

### 構成
KeVM は次の主要なコンポーネントで構成される．
* プログラム
  * 実行するプログラム．
  * 単一の命令列で構成される．つまり，関数毎に分割されてはいない．
* 汎用レジスタ群: r1, r2, ...
  * レジスタにはどんなデータ型のデータでも1つだけ格納できる．
  * レジスタの数に制限はない．
  * 全てのレジスタの機能は同等でる．特定のレジスタだけしか指定できないような命令は存在しない．
* データ用メモリ(以下，単にメモリと言う)
  * 番地を伴ってロードストア命令でアクセスできる．
  * 各番地にはどんなデータ型のデータでも1つだけ格納できる．
  * 番地は 0 以上の整数で指定する．番地の上限は2^31-1である．

## データ型

KeVM が扱うデータ型には次の型がある．
* 整数型: -2^31以上2^31-1以下の整数を表す．数値のほか，メモリの番地としても利用する．
* 文字列型: 文字列を表す．
* 実行番地型: プログラムの命令列中の位置を表す．関数呼び出しの戻り番地として使われる．整数型とは区別される．

レジスタやメモリの各番地には，これらのデータ型のうちのいずれかの型を持つデータが格納される．

## プログラム

プログラムは命令の列である．列の先頭から実行を開始する． EXIT 命令を実行すると，プログラムの実行を終了する．

プログラム中の命令にはラベルを付加することができる．ラベルは英字から始まり英数字で構成された列である．ラベルの末尾にコロンを追加したものを，ラベルを付加したい命令の直前に書く．

## 命令セット

### 定数ロード命令

#### NUMBER
```
NUMBER rd, N
```
##### 説明
レジスタ rd に整数型の整数 N を格納する．ただし， N は -2^31 以上 2^31 - 1 以下の整数でなければならない．
```
rd := N
```

#### STRING
```
STRING rd, S
```
#### 説明
レジスタ rd に文字列型の文字列 S を格納する．
```
rd := S
```

### データ転送命令

#### MOVE
```
MOVE rd, rs
```
##### 説明
レジスタ rd にレジスタ rs の内容を格納する．
```
rd := rs
```

### ロードストア命令

#### LOAD
```
LOAD ra, rd
```
##### 説明
メモリの，レジスタ ra が示す番地の内容を，レジスタ rd に格納する．
ra の内容は整数型でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
rd := memory[ra]
```

#### STORE
```
STORE ra, rs
```
##### 説明
メモリの，レジスタ ra が示す番地に，レジスタ rs の内容を格納する．
ra の内容は整数型でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
memory[ra] := rs
```


### 演算命令

#### ADD
```
ADD rd, ra, rb
```
##### 説明
レジスタ rd にレジスタ ra と rb の和を格納する．レジスタ ra と rb の内容は整数でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
if typeof(rb) != INTEGER then
  error
end
rd := ra + rb
```

#### SUB
#### MUL
#### DIV
#### AND
```
AND rd, ra, rb
```
##### 説明
レジスタ rd にレジスタ ra と rb のビット毎の論理積を格納する．レジスタ ra と rb の内容は整数型でなければならない．
```
if typeof(ra) != INTEGER then
  error
end
if typeof(rb) != INTEGER then
  error
end
rd = ra & rb
```

#### OR
#### XOR

### 比較命令

#### EQ
```
EQ rd, ra, rb
```
##### 説明
ra と rb の内容が等しければレジスタ rd に 1 を，そうでなければレジスタ rd に 0 を格納する．
```
if ra = rb then
  rd := 1
else
  rd := 0
end
```

#### NE
#### LT
#### GT

### 分岐命令

#### JMP
```
JMP LABEL
```
##### 説明
ラベル LABEL が付いている命令に制御を移す．
```
goto LABEL
```

#### JMPT
```
JMPT r, LABEL
```
##### 説明
レジスタ r の内容が 0 でないとき，ラベル LABEL が付いている命令に制御を移す．
```
if r != 0 then
  goto LABEL
end
```

#### JMPF
```
JMPF r, LABEL
```
##### 説明
レジスタ r の内容が 0 のとき，ラベル LABEL が付いている命令に制御を移す．
```
if r != 0 then
  goto LABEL
end
```

#### CALL
```
CALL r, LABEL
```
##### 説明
戻り番地をレジスタ r に格納して， LABEL が付いている命令に制御を移す．戻り番地は実行番地型のデータである．
```
r := next_address(PC)
goto LABEL
```

#### RET
```
RET r
```
##### 説明
レジスタ r に格納されている番地に制御を移す．レジスタ r の内容は実行番地型でなければならない．
```
if typeof(r) != EXEC_ADDRESS then
  error
end
goto r
```

#### EXIT
```
EXIT
```
##### 説明
プログラムの実行を終了する．


## 組込み関数

### KeVM 標準関数呼出し規約

組込み関数の呼出しは，以下の KeVM 標準関数呼出し規約に従う．

#### 名前
関数名をラベルとする．

#### スタック
メモリ中にスタックを作る．スタックは上位番地に向かって伸びる．スタックトップの番地は r8 レジスタに格納する（r8 をスタックポインタとして利用する）． r8 レジスタは，有効なデータが格納された最上位の番地を保持する．

#### 関数呼び出し
* 戻り番地は r7 レジスタに格納する．つまり，`CALL r7 LABEL`で呼出す．
* 引数: 第 4 引数までの引数は r1, r2, r3, r4 レジスタに第 1 引数から順に格納して呼出す．それ以降の引数はスタックに積む．スタックトップが最後の引数になるよう，前の引数から順にスタックに積む．
* 戻り値: 戻り値は r1 レジスタに格納して戻る．
* レジスタの保存: 関数呼び出しから戻ると， r1 から r7 レジスタの内容は変化している可能性がある．それ以外のレジスタの内容は保存される．

### 組込み関数

#### get
```
INTEGER get()
```
入力から 10 進数をひとつ読み込んで，整数型のデータとして返す．

#### put
```
put(INTEGER x)
put(STRING x)
```
1 つ引数を受けとり，それを表示する．引数は整数型か文字列型でなければならない．


## 例

### 10の階乗を求めるプログラム
次のプログラムは 10 の階乗 (10*9* ... * 1) の計算をするプログラムである．
```
        number  r8, 0
        number  r1, 10
        call    r7, fact
        call    r7, put
        exit
fact:   number  r2, 1
        eq      r3, r1, r2
        jmpf    r3, rec
        ret     r7
rec:    add     r8, r8, r2
        store   r8, r1
        add     r8, r8, r2
        store   r8, r7
        sub     r1, r1, r2
        call    r7, fact
        number  r2, 1
        load    r8, r7
        sub     r8, r8, r2
        load    r8, r3
        sub     r8, r8, r2
        mul     r1, r1, r3
        ret     r7
```
このプログラムは次のアルゴリズムで階乗を計算している．
```
fact(10);

fact(n) =
  if n == 1 then
    return 1
  else
    return fact(n - 1) * n
  end
```
1行目はスタックポインた (r8) の初期化である．スタックは 1 番地から正の方向に向かって伸
びることにする．最初はスタックは空なので 1 番地の 1 つ下の番地である 0 番地を指すよう
に初期化する．

2, 3 行目で 10 を引数として関数 fact を呼び出す．  r7 は戻り番地を格納するレジスタで
ある．引数は r1 を介して渡す．その結果， 10 の階乗が r1 に格納されて
戻ってくる． 4 行目では， r1 に格納された fact の戻り値をそまま引数として，
関数 put を呼び出し， 10 の階乗を表示する． 5 行目でプログラムの実行を終了する．

ラベル fact (6行目)以降が関数 fact の定義である．引数は 2, 3 行目で r1 を
介して渡しした．この値を n とする．関数 fact の中では常に r2 に整数 1 を保持しておく．
まず fact の 2 行目で n が 1 かどうかを調べる．
1 であれば 1 の階乗である 1 を戻り値にして呼び出し元に戻ればよい．fact の 4 行目が
その処理になっている．戻り番地は 3 行目の`call r7, fact`によって r7 に格納されて
いる．

n が 1 でないとき（2 以上ということになる）は n - 1 の階乗を
計算するために rec に制御を移して関数 fact を再帰呼び出しする．
rec の 1 から 4 行目で， n と r7 を順にスタックに保存する（プッシュする）．
r2 は 1 を保持しているので，`add r8, r8, r2`でスタックポインタ (r8) を 1 増や
すことができる．r7 にはこの関数からの戻り番地が格納されているので保存しておく必要が
ある．rec の 5 行目で r1 に n - 1 を格納して，それを引数に rec の 6 行目で
関数 fact を再帰呼び出しする．関数 fact から戻ると r1 には n - 1 の階乗が格納
されている．

rec の 8 から 11 行目で， r7 と n を順にスタックから取り出すが，
その前に 7 行目で r2 に改めて 1 を格納する．これは，呼び出した先の関数が r2 を書き
変える可能性があるためである（KeVM 標準関数呼び出し規約参照）．実際には
呼び出し先の関数は fact 自身であり，そこでは r2 に 1 以外を格納しないことが分か
っているので，このプログラムの場合に限っては，rec の 7 行目はなくても正しく動作する．
r1 には n - 1 の階乗が格納されているので，n は r3 に取り出す．最後に rec の
12行目で n * (n - 1) を計算して戻る．
